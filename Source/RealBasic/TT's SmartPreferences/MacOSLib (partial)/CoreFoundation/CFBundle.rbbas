#tag ClassClass CFBundleInherits CFType	#tag Event		Function ClassID() As UInt32		  return me.ClassID		End Function	#tag EndEvent	#tag Method, Flags = &h0		 Shared Function Application() As CFBundle		  // returns this app's main bundle		  		  static app as new CFBundle		  return app		End Function	#tag EndMethod	#tag Method, Flags = &h0		 Shared Function CarbonFramework() As CFBundle		  static v as CFBundle = NewCFBundleFromID(CarbonBundleID)		  return v		End Function	#tag EndMethod	#tag Method, Flags = &h0		 Shared Function ClassID() As UInt32		  #if TargetMacOS		    declare function TypeID lib CoreFoundation.framework alias "CFBundleGetTypeID" () as UInt32		    static id as UInt32 = TypeID		    return id		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub Constructor()		  // This default constructor creates the application's CFBundle		  		  #if TargetMacOS		    declare function CFBundleGetMainBundle lib CoreFoundation.framework () as Ptr		    		    dim p as Ptr = CFBundleGetMainBundle		    if p <> nil then		      super.Constructor p, true		      me.Retain		    end if		  #endif		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function DataPointerNotRetained(symbolName as String) As Ptr		  #if TargetMacOS		    declare function CFBundleGetDataPointerForName lib CoreFoundation.framework (bundle as Ptr, symbolName as CFStringRef) as Ptr		    		    if not (self = nil) then		      return CFBundleGetDataPointerForName(self, symbolName)		    end if		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function ExecutableFile() As CFURL		  #if TargetMacOS		    declare function CFBundleCopyExecutableURL lib CoreFoundation.framework (theBundle as Ptr) as Ptr		    		    if (self <> nil) then		      return MakeCFURL(CFBundleCopyExecutableURL(self))		    else		      return nil		    end if		  #endif		  		  		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function FrameworksDirectory() As CFURL		  #if TargetMacOS		    declare function CFBundleCopyPrivateFrameworksURL lib CoreFoundation.framework (theBundle as Ptr) as Ptr		    		    if (self <> nil) then		      return MakeCFURL(CFBundleCopyPrivateFrameworksURL(self))		    else		      return nil		    end if		  #endif		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function FunctionPointerForName(symbolName as String) As Ptr		  #if TargetMacOS		    declare function CFBundleGetFunctionPointerForName lib CoreFoundation.framework (bundle as Ptr, functionName as CFStringRef) as Ptr		    		    if (self <> nil) then		      return CFBundleGetFunctionPointerForName(me.Reference, symbolName)		    else		      return nil		    end if		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function InfoDictionary() As CFDictionary		  #if TargetMacOS		    declare function CFBundleGetInfoDictionary lib CoreFoundation.framework (bundle as Ptr) as Ptr		    		    if (self <> nil) then		      return new CFDictionary(CFBundleGetInfoDictionary(me.Reference), not CFType.hasOwnership)		    else		      return nil		    end if		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function InfoDictionaryValue(key as String) As CFType		  #if TargetMacOS		    declare function CFBundleGetValueForInfoDictionaryKey lib CoreFoundation.framework (bundle as Ptr, key as CFStringRef) as Ptr		    		    if (self <> nil) then		      dim valueRef as Ptr = CFBundleGetValueForInfoDictionaryKey(self, key)		      if valueRef <> nil then		        return CFType.NewObject(valueRef, not CFType.hasOwnership, kCFPropertyListImmutable)		      else		        return nil		      end if		      		    else		      return nil		    end if		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Load() As Boolean		  #if TargetMacOS		    if (self <> nil) then		      dim ok as Boolean		      // only available in Mac OS X 10.5 and later:		      if System.IsFunctionAvailable("CFBundleLoadExecutableAndReturnError", CoreFoundation.framework) then		        soft  declare function CFBundleLoadExecutableAndReturnError lib CoreFoundation.framework (theBundle as Ptr, ByRef errorOut as Ptr) as Boolean		        dim errorRef as Ptr		        ok = CFBundleLoadExecutableAndReturnError (me.Reference, errorRef)		        if errorRef <> nil then		          dim error as new CFError(errorRef, CFType.hasOwnership)		          #pragma unused error		          //I'd prefer to raise an exception, but for now we just create the CFError object for possible debugging.		        end if		      else		        // this works in all OS X versions:		        declare function CFBundleLoadExecutable lib CoreFoundation.framework (theBundle as Ptr) as Boolean		        ok = CFBundleLoadExecutable (me.Reference)		      end if		      return ok		    else		      return false		    end if		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Shared Function MakeCFURL(urlRef as Ptr, hasOwnership as Boolean = true) As CFURL		  #if TargetMacOS		    declare function CFBundleCopyExecutableURL lib CoreFoundation.framework (theBundle as Ptr) as Ptr		    		    if urlRef <> nil then		      return new CFURL(urlRef, hasOwnership)		    else		      return nil		    end if		  #endif		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		 Shared Function NewCFBundleFromID(bundleIdentifier as String) As CFBundle		  #if TargetMacOS		    declare function CFBundleGetBundleWithIdentifier lib CoreFoundation.framework (bundleID as CFStringRef) as Ptr		    		    return new CFBundle(CFBundleGetBundleWithIdentifier(bundleIdentifier), false)		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h0		 Shared Function NewCFBundleFromURL(theURL as CFURL) As CFBundle		  #if TargetMacOS		    if not (theURL is nil) then		      declare function CFBundleCreate lib CoreFoundation.framework (allocator as Ptr, bundleURL as Ptr) as Ptr		      		      return new CFBundle(CFBundleCreate(nil, theURL.Reference), true)		    end if		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h0		 Shared Function NewCFBundlesFromFolder(folderURL as CFURL) As CFArray		  #if TargetMacOS		    if not (folderURL is nil) then		      declare function CFBundleCreateBundlesFromDirectory lib CoreFoundation.framework (allocator as Ptr, folderURL as Ptr, bundleType as Ptr) as Ptr		      		      dim p as Ptr = CFBundleCreateBundlesFromDirectory(nil, folderURL.Reference, nil)		      if p <> nil then		        return new CFArray (p, true)		      end if		    end if		  #endif		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Resource(name as String, type as String, subDirectoryName as String) As CFURL		  raise new RuntimeException // not available		  'if not ( self = nil ) then		  '#if TargetMacOS		  'declare function CFBundleCopyResourceURL lib CoreFoundation.framework (bundle as Integer, resourceName as Integer, resourceType as Integer, subDirName as Integer) as Integer		  'declare function CFBundleCopyResourceURLInDirectory lib CoreFoundation.framework (bundleURL as Integer, resourceName as Integer, resourceType as Integer, subDirName as Integer) as Integer		  'declare function CFBundleCopyBundleURL lib CoreFoundation.framework (bundle as Integer) as Integer		  '		  'dim theRef as Integer		  'dim theURL as CFURL		  'dim typeRef as Integer		  'dim subDirRef as Integer		  'dim urlRef as Integer		  '		  'If name Is Nil then		  'Return Nil		  'End if		  'If type Is Nil then		  'typeRef = 0		  'Else		  'typeRef = type		  'End if		  'If subDirectoryName Is Nil then		  'subDirRef = 0		  'Else		  'subDirRef = subDirectoryName		  'End if		  '		  'theRef = CFBundleCopyResourceURL(me, name, typeRef, subDirRef)		  'CoreFoundation.CheckCFTypeRef theRef, "CFBundle", "Resource", "CFBundleCopyResourceURL"		  'theURL = new CFURL(theRef)		  '#endif		  '		  'Exception oops as CFTypeRefException		  'theURL = Nil		  '		  'Finally		  'CoreFoundation.Release theRef		  'Return theURL		  'End		  		  #pragma unused name		  #pragma unused type		  #pragma unused subDirectoryName		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function ResourcesDirectory() As CFURL		  #if TargetMacOS		    declare function CFBundleCopyResourcesDirectoryURL lib CoreFoundation.framework (theBundle as Ptr) as Ptr		    		    if (self <> nil) then		      return MakeCFURL(CFBundleCopyResourcesDirectoryURL(self))		    else		      return nil		    end if		  #endif		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function StringPointerRetained(symbolName as String) As CFStringRef		  #if TargetMacOS		    declare function CFBundleGetDataPointerForName lib CoreFoundation.framework (bundle as Ptr, symbolName as CFStringRef) as Ptr		    declare function CFRetain lib CoreFoundation.framework (cf as Ptr) as CFStringRef		    		    if (self <> nil) then		      dim p as Ptr = CFBundleGetDataPointerForName(me.Reference, symbolName)		      if p <> nil then		        return CFRetain (p.Ptr(0))		      else		        return ""		      end if		    else		      return ""		    end if		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function SupportFilesDirectory() As CFURL		  #if TargetMacOS		    declare function CFBundleCopySupportFilesDirectoryURL lib CoreFoundation.framework (bundle as Ptr) as Ptr		    		    if (self <> nil) then		      return MakeCFURL(CFBundleCopySupportFilesDirectoryURL(self))		    else		      return nil		    end if		  #endif		  		End Function	#tag EndMethod	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  #if TargetMacOS			    return URL.Item			  #endif			End Get		#tag EndGetter		FolderItem As FolderItem	#tag EndComputedProperty	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  #if TargetMacOS			    declare function CFBundleGetIdentifier lib CoreFoundation.framework (bundle as Ptr) as Ptr			    			    if (self <> nil) then			      return RetainedStringValue(CFBundleGetIdentifier(self))			    else			      return ""			    end if			  #endif			End Get		#tag EndGetter		Identifier As String	#tag EndComputedProperty	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  #if TargetMacOS			    declare function CFBundleCopyBundleURL lib CoreFoundation.framework (bundle as Ptr) as Ptr			    			    if (self <> nil) then			      dim theURL as new CFURL(CFBundleCopyBundleURL(me.Reference), true)			      if not theURL.Equals(nil) then			        return theURL			      else			        return nil			      end if			    end if			  #endif			End Get		#tag EndGetter		URL As CFURL	#tag EndComputedProperty	#tag ViewBehavior		#tag ViewProperty			Name="Description"			Group="Behavior"			Type="String"			EditorType="MultiLineEditor"			InheritedFrom="CFType"		#tag EndViewProperty		#tag ViewProperty			Name="Identifier"			Group="Behavior"			Type="String"			EditorType="MultiLineEditor"		#tag EndViewProperty		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			InitialValue="-2147483648"			Type="Integer"			InheritedFrom="CFType"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			InitialValue="0"			Type="Integer"			InheritedFrom="CFType"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			Type="String"			InheritedFrom="CFType"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			Type="String"			InheritedFrom="CFType"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			InitialValue="0"			Type="Integer"			InheritedFrom="CFType"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass