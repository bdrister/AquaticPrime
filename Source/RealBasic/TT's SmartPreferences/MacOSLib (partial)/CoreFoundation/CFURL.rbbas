#tag ClassClass CFURLInherits CFType	#tag Event		Function ClassID() As UInt32		  return me.ClassID		End Function	#tag EndEvent	#tag Event		Function VariantValue() As Variant		  return me.StringValue		End Function	#tag EndEvent	#tag Method, Flags = &h0		Function AbsoluteURL() As CFURL		  #if TargetMacOS		    declare function CFURLCopyAbsoluteURL lib CoreFoundation.framework (relativeURL as Ptr) as Ptr		    		    if me.Reference <> nil then		      return new CFURL(CFURLCopyAbsoluteURL(me), true)		    else		      return new CFURL(nil, not CFType.hasOwnership)		    end if		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function AppendComponent(pathComponent as String, isDirectory as Boolean) As CFURL		  //creates a new CFURL object with pathComponent appended to the path of this object.		  //isDirectory tells the function whether to add a trailing slash.		  #if TargetMacOS		    declare function CFURLCreateCopyAppendingPathComponent lib CoreFoundation.framework (allocator as Ptr, url as Ptr, pathComponent as CFStringRef, isDirectory as Boolean) as Ptr		    		    return new CFURL(CFURLCreateCopyAppendingPathComponent(nil, self, pathComponent, isDirectory), CFType.hasOwnership)		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h0		 Shared Function ClassID() As UInt32		  #if TargetMacOS		    declare function TypeID lib CoreFoundation.framework alias "CFURLGetTypeID" () as UInt32		    static id as UInt32 = TypeID		    return id		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub Constructor(baseURL as CFURL, relativeURL as String)		  #if TargetMacOS		    declare function CFURLCreateWithString lib CoreFoundation.framework (allocator as Ptr, URLString as CFStringRef, baseURL as Ptr) as Ptr		    		    if baseURL is nil then		      super.Constructor CFURLCreateWithString(nil, relativeURL, nil), true		    else		      super.Constructor CFURLCreateWithString(nil, relativeURL, baseURL.Reference), true		    end if		  #endif		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Constructor(f as FolderItem)		  if not (f is nil) then		    me.Constructor f.URLPath		  else		    me.Constructor nil, not CFType.hasOwnership		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Constructor(theURL as String)		  me.Constructor nil, theURL		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Shared Function CopyHostName(url as CFURL) As Ptr		  #if TargetMacOS		    declare function CFURLCopyHostName lib CoreFoundation.framework (aURL as Ptr) as Ptr		    		    return CFURLCopyHostName(url)		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Shared Function CopyNetLocation(url as CFURL) As Ptr		  #if TargetMacOS		    declare function CFURLCopyNetLocation lib CoreFoundation.framework (aURL as Ptr) as Ptr		    		    return CFURLCopyNetLocation(url)		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Shared Function CopyPassword(url as CFURL) As Ptr		  #if TargetMacOS		    declare function CFURLCopyPassword lib CoreFoundation.framework (aURL as Ptr) as Ptr		    		    return CFURLCopyPassword(url)		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Shared Function CopyQueryString(url as CFURL) As Ptr		  #if TargetMacOS		    declare function CFURLCopyQueryString lib CoreFoundation.framework (aURL as Ptr) as Ptr		    		    return CFURLCopyQueryString(url)		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Shared Function CopyScheme(url as CFURL) As Ptr		  #if TargetMacOS		    declare function CFURLCopyScheme lib CoreFoundation.framework (aURL as Ptr) as Ptr		    		    return CFURLCopyScheme(url)		  #endif		End Function	#tag EndMethod	#tag DelegateDeclaration, Flags = &h21		Private Delegate Function CopyStringValueDelegate(url as CFURL) As Ptr	#tag EndDelegateDeclaration	#tag Method, Flags = &h21		Private Shared Function CopyUserName(url as CFURL) As Ptr		  #if TargetMacOS		    declare function CFURLCopyUserName lib CoreFoundation.framework (aURL as Ptr) as Ptr		    		    return CFURLCopyUserName(url)		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Shared Function CreateFromFilesystemPath(path as String, pathType as Integer, isDirectory as Boolean) As CFURL		  #if TargetMacOS		    const kCFAllocatorDefault = nil		    		    dim p as Ptr = CoreFoundation.CFURLCreateWithFileSystemPath(kCFAllocatorDefault, path, pathType, isDirectory)		    return new CFURL(p, CFType.hasOwnership)		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h0		 Shared Function CreateFromFSRef(fsRef as MemoryBlock) As CFURL		  #if TargetMacOS		    declare function CFURLCreateFromFSRef lib CoreFoundation.framework (allocator as Ptr, fsRef as Ptr) as Ptr		    		    const kCFAllocatorDefault = nil		    		    dim p as Ptr = CFURLCreateFromFSRef (kCFAllocatorDefault, fsRef)		    return new CFURL(p, CFType.hasOwnership)		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h0		 Shared Function CreateFromHFSPath(path as String, isDirectory as Boolean) As CFURL		  return CreateFromFilesystemPath(path, CFURL.HFSPathStyle, isDirectory)		End Function	#tag EndMethod	#tag Method, Flags = &h0		 Shared Function CreateFromPOSIXPath(path as String, isDirectory as Boolean) As CFURL		  return CreateFromFilesystemPath(path, CFURL.POSIXPathStyle, isDirectory)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function HostName() As String		  return me.StringValue(AddressOf CopyHostName)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Icon(custom as Boolean) As NSImageMBS		  declare function CFURLCopyResourcePropertyForKey lib CoreFoundation.framework (url as Ptr, key as CFStringRef, ByRef outPtr as Ptr, error as Ptr) as Boolean		  declare sub CGImageRelease lib CoreFoundation.framework (p as Ptr)		  		  if me.Reference <> nil then		    dim p as Ptr		    if CFURLCopyResourcePropertyForKey (me.Reference, "NSURLEffectiveIconKey", p, nil) then		      if p = nil then		        return nil		      else		        dim res as NSImageMBS = NSImageMBS.imageWithHandle (Integer(p))		        CGImageRelease (p)		        return res		      end if		    else		      break		    end if		  end		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function IsDecomposable() As Boolean		  #if TargetMacOS		    declare function CFURLCanBeDecomposed lib CoreFoundation.framework (aURL as Ptr) as Boolean		    		    if me <> nil then		      return CFURLCanBeDecomposed(me)		    end if		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Kind() As String		  declare function CFURLCopyResourcePropertyForKey lib CoreFoundation.framework (url as Ptr, key as CFStringRef, ByRef outPtr as Ptr, error as Ptr) as Boolean		  		  if me.Reference <> nil then		    dim p as Ptr		    if CFURLCopyResourcePropertyForKey (me.Reference, "NSURLLocalizedTypeDescriptionKey", p, nil) and p <> nil then		      dim cfs as new CFString(p, CFType.hasOwnership)		      return cfs.StringValue		    end if		  end if		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function LabelName() As String		  declare function CFURLCopyResourcePropertyForKey lib CoreFoundation.framework (url as Ptr, key as CFStringRef, ByRef outPtr as Ptr, error as Ptr) as Boolean		  		  if me.Reference <> nil then		    dim p as Ptr		    if CFURLCopyResourcePropertyForKey (me.Reference, "NSURLLocalizedLabelKey", p, nil) then		      if p = nil then		        return ""		      else		        dim cfs as new CFString(p, CFType.hasOwnership)		        return cfs.StringValue		      end if		    else		      break		    end if		  end if		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function NetLocation() As String		  return me.StringValue(AddressOf CopyNetLocation)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Password() As String		  return me.StringValue(AddressOf CopyPassword)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Path(resolveAgainstBase as Boolean = true) As String		  #if TargetMacOS		    if me.Reference <> nil then		      dim buffer as new MemoryBlock(2048)		      do		        declare function CFURLGetFileSystemRepresentation lib CoreFoundation.framework (url as Ptr, resolveAgainstBase as Boolean, buffer as Ptr, maxBufLen as Integer) as Boolean		        		        if CFURLGetFileSystemRepresentation(me.Reference, resolveAgainstBase, buffer, buffer.Size) then		          exit		        else		          buffer.Size = 2*buffer.Size		        end if		      loop until buffer.Size > 65536		      return DefineEncoding(buffer.CString(0), Encodings.UTF8)		    end if		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Port() As Integer		  #if TargetMacOS		    declare function CFURLGetPortNumber lib CoreFoundation.framework (anURL as Ptr) as Integer		    if me <> nil then		      return CFURLGetPortNumber(me)		    else		      //CFURLGetPortNumber returns -1 if not port exists; a url for which this holds is http://www.apple.com/ .  We return -1 in the case of a nil object for consistency.		      return -1		    end if		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function QueryString() As String		  return me.StringValue(AddressOf CopyQueryString)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Scheme() As String		  return me.StringValue(AddressOf CopyScheme)		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Function StringValue(f as CopyStringValueDelegate) As String		  //if f  = nil, then that's a programmer error.		  #if TargetMacOS		    if me.Reference <> nil then		      return NotRetainedStringValue(f.Invoke(me))		    else		      return ""		    end if		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function UserName() As String		  return me.StringValue(AddressOf CopyUserName)		End Function	#tag EndMethod	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  #if TargetMacOS			    declare function CFURLGetBaseURL lib CoreFoundation.framework (aURL as Ptr) as Ptr			    			    if not ( self = nil ) then			      dim theBaseURL as new CFURL(CFURLGetBaseURL(me.Reference), false)			      if not ( theBaseURL = nil ) then			        return theBaseURL			      end if			    end if			  #endif			End Get		#tag EndGetter		BaseURL As CFURL	#tag EndComputedProperty	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  if not ( self = nil ) then			    return GetFolderItem(me.StringValue, FolderItem.PathTypeURL)			  end if			End Get		#tag EndGetter		Item As FolderItem	#tag EndComputedProperty	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  // returns only the relative part of a URL!			  			  #if TargetMacOS			    declare function CFURLGetString lib CoreFoundation.framework (aURL as Ptr) as Ptr			    // Caution: If this would return a CFStringRef, we'd have to Retain its value!			    // Instead, "new CFString()" takes care of that below			    			    if not ( self = nil ) then			      return new CFString(CFURLGetString(me.Reference), false)			    end if			  #endif			End Get		#tag EndGetter		RelativeURL As String	#tag EndComputedProperty	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  // returns the full URL (including the base)			  			  #if true			    return me.AbsoluteURL().RelativeURL			  #else			    // this works, too, but the above one seems more proper			    dim base as CFURL = me.BaseURL			    if not (base is nil) and not base.IsNULL then			      return me.BaseURL.StringValue+me.RelativeURL			    else			      return me.RelativeURL			    end if			  #endif			End Get		#tag EndGetter		StringValue As String	#tag EndComputedProperty	#tag Constant, Name = HFSPathStyle, Type = Double, Dynamic = False, Default = \"1", Scope = Public	#tag EndConstant	#tag Constant, Name = POSIXPathStyle, Type = Double, Dynamic = False, Default = \"0", Scope = Public	#tag EndConstant	#tag Constant, Name = WindowsPathStyle, Type = Double, Dynamic = False, Default = \"2", Scope = Public	#tag EndConstant	#tag ViewBehavior		#tag ViewProperty			Name="Description"			Group="Behavior"			Type="String"			EditorType="MultiLineEditor"			InheritedFrom="CFType"		#tag EndViewProperty		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			InitialValue="-2147483648"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="RelativeURL"			Group="Behavior"			Type="String"			EditorType="MultiLineEditor"		#tag EndViewProperty		#tag ViewProperty			Name="StringValue"			Group="Behavior"			Type="String"			EditorType="MultiLineEditor"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass