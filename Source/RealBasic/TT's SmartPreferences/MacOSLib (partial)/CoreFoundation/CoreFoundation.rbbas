#tag ModuleModule CoreFoundation	#tag Method, Flags = &h1		Protected Function AvailableEncodings() As TextEncoding()		  #if TargetMacOS		    dim m as MemoryBlock		    dim i as Integer		    dim encodingList(-1) as TextEncoding		    		    Const kCFStringEncodingInvalidId = &hffffffff		    		    Declare Function CFStringGetListOfAvailableEncodings Lib CoreFoundation.framework () as Ptr		    		    m = CFStringGetListOfAvailableEncodings		    		    If m <> Nil then		      i = 0		      While m.Long(i) <> kCFStringEncodingInvalidId		        encodingList.Append Encodings.GetFromCode(m.Long(i))		        i = i + 4		      Wend		    Else		      //		    End if		    Return encodingList		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Bundle() As CFBundle		  return CFBundle.NewCFBundleFromID(BundleID)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function CFBoolean(b as Boolean) As CFBoolean		  if b then		    return CFBoolean.GetTrue		  end if		  return CFBoolean.GetFalse		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function CFConstant(name as String) As CFStringRef		  // To be used to look up kCF... constants only!		  		  return CoreFoundation.Bundle.StringPointerRetained(name)		End Function	#tag EndMethod	#tag ExternalMethod, Flags = &h0		Declare Function CFCopyTypeIDDescription Lib CoreFoundation.framework (type_id as UInt32) As CFStringRef	#tag EndExternalMethod	#tag Method, Flags = &h0		Function CFDate(d as Date) As CFDate		  return new CFDate(d)		End Function	#tag EndMethod	#tag ExternalMethod, Flags = &h21		Private Declare Function CFGetTypeID Lib CoreFoundation.framework (cf as Ptr) As UInt32	#tag EndExternalMethod	#tag Method, Flags = &h0		Function CFNumber(dbl as Double) As CFNumber		  return new CFNumber(dbl)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function CFNumber(int_32 as Int32) As CFNumber		  return new CFNumber(int_32)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function CFNumber(int_64 as Int64) As CFNumber		  return new CFNumber(int_64)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function CFRangeMake(loc as Integer, len as Integer) As CFRange		  dim r as CFRange		  r.location = loc		  r.length = len		  return r		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function CFSocketNativeHandle(handle as Integer) As CFSocketNativeHandle		  dim h as CFSocketNativeHandle		  h.handle = handle		  return h		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function CFString(str as String) As CFString		  return str		End Function	#tag EndMethod	#tag ExternalMethod, Flags = &h21		Private Declare Function CFStringGetTypeID Lib CoreFoundation.framework () As Uint32	#tag EndExternalMethod	#tag Method, Flags = &h0		Function CFURL(f as FolderItem) As CFURL		  return new CFURL(f)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function CFURL(url as String) As CFURL		  return new CFURL(url)		End Function	#tag EndMethod	#tag ExternalMethod, Flags = &h1		Protected Declare Function CFURLCreateWithFileSystemPath Lib CoreFoundation.framework (allocator as Ptr, filePath as CFStringRef, pathStyle as Integer, isDirectory as Boolean) As Ptr	#tag EndExternalMethod	#tag Method, Flags = &h0		Function Clone(Extends propertyList as CFPropertyList, mutability as Integer) As CFPropertyList		  // mutability: kCFPropertyListImmutable, kCFPropertyListMutableContainers, kCFPropertyListMutableContainersAndLeaves		  		  dim pList as CFType		  		  #if TargetMacOS		    Declare Function CFPropertyListCreateDeepCopy Lib CoreFoundation.framework (allocator as Integer, propertyList as Ptr, mutabilityOption as Integer) as Ptr		    		    dim ref as Ptr		    ref = CFPropertyListCreateDeepCopy(0, propertyList.Reference, mutability)		    If ref <> nil then		      pList = CFType.NewObject(ref, true, mutability)		    End if		  #endif		  		  return CFPropertyList(pList)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function IsValid(extends propertyList as CFPropertyList, listFormat as Integer) As Boolean		  // listFormat: kCFPropertyListOpenStepFormat, kCFPropertyListXMLFormat_v1_0, kCFPropertyListBinaryFormat_v1_0		  		  #if TargetMacOS		    Declare Function CFPropertyListIsValid Lib CoreFoundation.framework (cf as Ptr, fmt as Integer) as Boolean		    		    return CFPropertyListIsValid(propertyList.Reference, listFormat)		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function kCFAllocatorNull() As Ptr		  //kCFAllocatorNull does not resolve to nil.		  		  #if TargetMacOS		    dim b as CFBundle = CoreFoundation.Bundle		    dim p as Ptr = b.DataPointerNotRetained("kCFAllocatorNull")		    if p <> nil then		      return p.Ptr(0)		    else		      return nil		    end if		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function NewCFPropertyList(theXML as CFData, mutability as Integer, ByRef errorMessageOut as String) As CFPropertyList		  // mutability: kCFPropertyListImmutable, kCFPropertyListMutableContainers, kCFPropertyListMutableContainersAndLeaves		  // Note: Returns nil if the xml data is not a valid property list		  		  dim pList as CFType		  		  #if TargetMacOS		    declare function CFPropertyListCreateFromXMLData Lib CoreFoundation.framework (allocator as Ptr, xmlData as Ptr, mutabilityOptions as Integer, ByRef errMsg as CFStringRef) as Ptr		    		    dim theRef as Ptr		    		    dim strRef as CFStringRef		    theRef = CFPropertyListCreateFromXMLData (nil, theXML, mutability, strRef)		    if theRef <> nil then		      pList = CFType.NewObject(theRef, true, mutability)		      errorMessageOut = ""		    else		      errorMessageOut = strRef		    end if		  #else		    errorMessageOut = "not supported on this platform"		  #endif		  		  return CFPropertyList(pList)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function NewCFPropertyList(openedStream as CFReadStream, mutability as Integer, ByRef formatOut as Integer, ByRef errorMessageOut as String) As CFPropertyList		  // mutability: kCFPropertyListImmutable, kCFPropertyListMutableContainers, kCFPropertyListMutableContainersAndLeaves		  // Note: Returns nil if the xml data is not a valid property list		  		  dim pList as CFType		  		  #if TargetMacOS		    declare function CFPropertyListCreateFromStream Lib CoreFoundation.framework (allocator as Ptr, readStream as Ptr, streamLen as Integer, mutabilityOptions as Integer, ByRef format as Integer, ByRef errMsg as CFStringRef) as Ptr		    		    dim theRef as Ptr		    dim strRef as CFStringRef		    theRef = CFPropertyListCreateFromStream (nil, openedStream.Reference, 0, mutability, formatOut, strRef)		    if theRef <> nil then		      pList = CFType.NewObject(theRef, true, mutability)		      errorMessageOut = ""		    else		      errorMessageOut = strRef		    end if		  #else		    errorMessageOut = "not supported on this platform"		  #endif		  		  return CFPropertyList(pList)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function NewCFPropertyList(theXML as String, mutability as Integer, ByRef errorMessageOut as String) As CFPropertyList		  #if TargetMacOS		    return NewCFPropertyList(new CFData(theXML), mutability, errorMessageOut)		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function NotRetainedStringValue(p as Ptr) As String		  #if TargetMacOS		    if p = nil then		      return ""		    end if		    		    if CFGetTypeID(p) <> CFStringGetTypeID then		      dim e as new TypeMismatchException		      e.Message = "CFTypeRef &h" + Hex(Integer(p)) + " has unexpected type " + CFCopyTypeIDDescription(CFGetTypeID(p)) + "."		      raise e		    end if		    		    declare function CFStringGetLength lib CoreFoundation.framework (cf as Ptr) as Integer		    declare function CFStringGetMaximumSizeForEncoding lib CoreFoundation.framework (length as Integer, enc as Integer) as Integer		    declare function CFStringGetCString lib CoreFoundation.framework (theString as Ptr, buffer as Ptr, bufferSize as Integer, enc as Integer) as Boolean		    		    dim maxSize as Integer = CFStringGetMaximumSizeForEncoding(CFStringGetLength(p), kCFStringEncodingUTF8)		    if maxSize <= 0 then		      return ""		    end if		    		    dim buffer as new MemoryBlock(1 + maxSize)		    if CFStringGetCString(p, buffer, buffer.Size, kCFStringEncodingUTF8) then		      return DefineEncoding(buffer.CString(0), Encodings.UTF8)		    else		      return ""		    end if		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function RetainedStringValue(p as Ptr) As String		  #if TargetMacOS		    declare function CFRetain lib CoreFoundation.framework (cf as Ptr) as Ptr		    		    if p <> nil then		      return NotRetainedStringValue(CFRetain(p))		    else		      return ""		    end if		  #endif		End Function	#tag EndMethod	#tag DelegateDeclaration, Flags = &h1		Protected Delegate Sub TimerActionDelegate()	#tag EndDelegateDeclaration	#tag Method, Flags = &h1		Protected Function Version() As Double		  // Returns the version of the CoreFoundation framework		  		  #if TargetMacOS		    const kCFCoreFoundationVersionNumber = "kCFCoreFoundationVersionNumber"		    		    dim p as Ptr = CFBundle.NewCFBundleFromID(CoreFoundation.BundleID).DataPointerNotRetained(kCFCoreFoundationVersionNumber)		    if p <> nil then		      return p.Double(0)		    end if		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Write(extends propertyList as CFPropertyList, openedWriteStream as CFWriteStream, format as Integer, ByRef errorMessageOut as String) As Boolean		  #if TargetMacOS		    declare function CFPropertyListWriteToStream lib CoreFoundation.framework (propertyList as Ptr, stream as Ptr, format as Integer, ByRef errMsg as CFStringRef) as Integer		    		    dim strRef as CFStringRef		    dim written as Integer = CFPropertyListWriteToStream (propertyList.Reference, openedWriteStream.Reference, format, strRef)		    errorMessageOut = strRef		    if errorMessageOut = "" then		      // success		      return written > 0		    end if		  #else		    errorMessageOut = "not supported on this platform"		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function XMLValue(extends propertyList as CFPropertyList) As String		  #if TargetMacOS		    declare function CFPropertyListCreateXMLData lib CoreFoundation.framework (allocator as Ptr, propertyList as Ptr) as Ptr		    		    dim xmlData as new CFData(CFPropertyListCreateXMLData(nil, propertyList.Reference), true)		    return DefineEncoding(xmlData.Data, Encodings.UTF8)		  #endif		End Function	#tag EndMethod	#tag Note, Name = About		CFType and its subclasses are wrappers for Mac OS's CoreFoundation classes, which encompass		numbers, strings, arrays, dictionaries and a few more common types. The CoreGraphics module		also makes use of, and extends, these classes.				As a first time user, start looking at CFPreferences to read/write your app's ".plist" prefs file,		and at CFBundle, using its Application() method to get to your app bundle's folders (those		hidden in your app package).				Important: If you are adding or modifying new functionality using Declare statements,		make sure you understand the reference counting rules. Read the "Memory Management"		note in the CFType class for a start.				Original sources are located here:  http://code.google.com/p/macoslib	#tag EndNote	#tag Note, Name = Comparing values		There are three ways to compare objects of CFType and their subclasses:				1. As they're objects, one may want to see if two RB variables identify the same		   RB object, or if one is nil. To test this, use the "is" operator, e.g.:				     if cfDict.Value(x) is nil then ... // tests if a dictionary entry exists				2. As they reference a CoreFoundation object managed by OS X, one can test		   if two RB objects reference the same CF object. Use the "="operator for this		   (this is achieved by the Operator_Compare() function in the CFType class):				     if cfArray.Value(i) = item then ... // test if item is already in the array				   A special case is the NULL CF reference. To test if a CF class identifies		   no CF object, you can use the IsNULL function.				3. Finally, all CF objects refer to data (unless IsNULL() returns true). To access		   that data, you need to retrieve it explicitly (exception: CFStrings can be		   automatically coerced into Strings and vice versa).		   In general, to check if two separate CF objects are equal, use the		   Equals() function:				     if cfNum1.Equals (cfNum2) then ... // test if their values are equal				   Additionally, to order two CFNumber values, you cannot use "<" and		   ">" on the CF objects but must compare their explicit values instead:				     if n1.IntegerValue > n2.IntegerValue then ... // number compare	#tag EndNote	#tag Note, Name = NULL references (nil ptrs)		New rule implemented on 23 Dec 08:				If a CF... class gets constructed from a nil reference, it will still be created		(as a CFType whose IsNULL() function returns true).		That way, you can always expect that a function that returns CF type values		will get you an existing object and not nil. To test if the reference is nil,		call the IsNULL() member function.		Note, however, that CFDictionary.Value and CFPreferences.Value may still		return nil if the given key does not exist in the dictionary or prefs.	#tag EndNote	#tag Constant, Name = BundleID, Type = String, Dynamic = False, Default = \"com.apple.CoreFoundation", Scope = Protected	#tag EndConstant	#tag Constant, Name = CarbonBundleID, Type = String, Dynamic = False, Default = \"com.apple.Carbon", Scope = Protected	#tag EndConstant	#tag Constant, Name = framework, Type = String, Dynamic = False, Default = \"CoreFoundation.framework", Scope = Protected	#tag EndConstant	#tag Constant, Name = kCFCompareAnchored, Type = Double, Dynamic = False, Default = \"8", Scope = Public	#tag EndConstant	#tag Constant, Name = kCFCompareBackwards, Type = Double, Dynamic = False, Default = \"4", Scope = Public	#tag EndConstant	#tag Constant, Name = kCFCompareCaseInsensitive, Type = Double, Dynamic = False, Default = \"1", Scope = Public	#tag EndConstant	#tag Constant, Name = kCFCompareDiacriticInsensitive, Type = Double, Dynamic = False, Default = \"128", Scope = Public	#tag EndConstant	#tag Constant, Name = kCFCompareForcedOrdering, Type = Double, Dynamic = False, Default = \"512", Scope = Public	#tag EndConstant	#tag Constant, Name = kCFCompareLikeFinder, Type = Double, Dynamic = False, Default = \"881", Scope = Public	#tag EndConstant	#tag Constant, Name = kCFCompareLocalized, Type = Double, Dynamic = False, Default = \"32", Scope = Public	#tag EndConstant	#tag Constant, Name = kCFCompareNonliteral, Type = Double, Dynamic = False, Default = \"16", Scope = Public	#tag EndConstant	#tag Constant, Name = kCFCompareNumerically, Type = Double, Dynamic = False, Default = \"64", Scope = Public	#tag EndConstant	#tag Constant, Name = kCFCompareWidthInsensitive, Type = Double, Dynamic = False, Default = \"256", Scope = Public	#tag EndConstant	#tag Constant, Name = kCFPropertyListBinaryFormat_v1_0, Type = Double, Dynamic = False, Default = \"200", Scope = Public	#tag EndConstant	#tag Constant, Name = kCFPropertyListImmutable, Type = Double, Dynamic = False, Default = \"0", Scope = Public	#tag EndConstant	#tag Constant, Name = kCFPropertyListMutableContainers, Type = Double, Dynamic = False, Default = \"1", Scope = Public	#tag EndConstant	#tag Constant, Name = kCFPropertyListMutableContainersAndLeaves, Type = Double, Dynamic = False, Default = \"2", Scope = Public	#tag EndConstant	#tag Constant, Name = kCFPropertyListOpenStepFormat, Type = Double, Dynamic = False, Default = \"1", Scope = Public	#tag EndConstant	#tag Constant, Name = kCFPropertyListXMLFormat_v1_0, Type = Double, Dynamic = False, Default = \"100", Scope = Public	#tag EndConstant	#tag Constant, Name = kCFStringEncodingUTF8, Type = Double, Dynamic = False, Default = \"&h08000100", Scope = Public	#tag EndConstant	#tag Structure, Name = CFRange, Flags = &h0, Attributes = \"StructureAlignment \x3D 1"		location as Integer		length as Integer	#tag EndStructure	#tag Structure, Name = CFSocketContext, Flags = &h0		version as Integer		  info as Integer		  retainFunc as Ptr		  releaseFunc as Ptr		copyDescFunc as Ptr	#tag EndStructure	#tag Structure, Name = CFSocketNativeHandle, Flags = &h0		handle as Integer	#tag EndStructure	#tag ViewBehavior		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			InitialValue="-2147483648"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty	#tag EndViewBehaviorEnd Module#tag EndModule